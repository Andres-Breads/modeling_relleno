\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{graphicx}

\title{Complejidad y Optimización \\
Problema del Relleno Sanitario}
\author{Carlos Andrés Aucaruri Correa}
\date{Febrero 16 2022}

\begin{document}

\maketitle

\pagebreak

\tableofcontents

\pagebreak

\section{Modelo}
La región EcoReg tiene un problema serio de depósito de basuras, y ha decidido construir un nuevo relleno dentro de sus fronteras. Como es natural,
cada ciudad dentro de la región está en alerta y presionando para que el sitio no quede cerca de su ciudad. Por tal razón, los administradores de la región
quieren encontrar un sitio que quede lo más lejos posible de la ciudad más cercana. Los administradores
han decidido medir la distancia entre dos ciudades con la métrica Manhattan la cual define la distancia
entre dos puntos como la distancia en el eje X más la distancia en el eje Y.

La región se representa como un cuadrado perfecto de N km por N km. Identificamos la esquina al suroccidente de la región con la posición (0,0).
En este sistema, las ciudades están situadas sobre las intersecciones.

\subsection{Parámetros}
\begin{itemize}
    \item $m$: representa el número de ciudades
    \item $n$: representa el tamaño de la región cuadrada tal que $n \geq 0$
    \item $Ciudad_ix$: representa la coordenada en $x$ ($0 \leq x \leq n$) de cada ciudad $i$ ($\forall i \in \{1,...,m\}$).
    \item $Ciudad_iy$: representa la coordenada en $y$ ($0 \leq y \leq n$) de cada ciudad $i$ ($\forall i \in \{1,...,m\}$).
\end{itemize}

\subsection{Variables}
\begin{itemize}
    \item $Relleno_x$: representa la coordenada en $x$ del relleno sanitario ($0 \leq x \leq n$).
    \item $Relleno_y$: representa la coordenada en $y$ del relleno sanitario ($0 \leq y \leq n$).
    \item $Distancia$: representa la distancia Manhattan del relleno sanitario a la ciudad más cercana ($0 \leq Distancia \leq n*2$).
    \item $CiudadCercana_x$: representa la coordenada en $x$ de la ciudad más cercana ($0 \leq x \leq n$).
    \item $CiudadCercana_y$: representa la coordenada en $y$ de la ciudad más cercana ($0 \leq y \leq n$).
\end{itemize}

\subsection{Restricciones}
\begin{itemize}
    \item El relleno debe encontrar la distancia más cercana entre todas las ciudades:
    $Distancia = \min( |Ciudad_ix - Relleno_x| + |Ciudad_iy - Relleno_y|, \{ \forall i \in \{1,...,m\} \})$
    \item La ciudad más cercana será la que coincida con la distancia encontrada
    Para minizinc tendremos las siguientes Restricciones usando la restriccion global "table.mzn":
    \begin{lstlisting}
    constraint table(ciudad_cercana, ciudades);
    constraint abs(ciudad_cercana[1] - relleno_x) +
        abs(ciudad_cercana[2] - relleno_y) == distancia;
    \end{lstlisting}
\end{itemize}

\subsection{Función Objetivo}
Maximice: $Distancia$

\section{Detalles importantes de implementación}
La implementación de Minizinc junto con Python se realizó sin problemas debido a que minizinc cuenta con buena documentación al respecto,
lo único que se tiene en cuenta durante la selección de los solvers es que Globalizer y findMUS no están correctamente desarrollados al momento de probarlos con la librería.
Adicionalmente, se buscaba utilizar las funciones asíncronas que mostraba la documentación, pero al intentarlo, la librería respondía con la excepción de que no estaban implementadas todavía.

El framework usado para la interfaz gráfica fue PythonQt que viene desarrollado con multitud de widgets y herramientas como QtDesigner que ayudan a la rápida construcción
de la interfaz.

\section{Pruebas}
Para ayudar a probar el modelo con nuevos datos adicionales a los presentados originalmente, se dearrolló un programa en python que genera un archivo .dzn
con datos aleatorios correspondientes a los parámetros del modelo. Con lo cual se probaron diferentes archivos generados con los solvers que provee Minizinc.

\section{Análisis}
Para el análisis de los datos ingresados, se usaron 11 archivos con diferentes tamaños de región, y un número de ciudades que se repiten para cada región
de modo que tenemos 10, 60 y 200 ciudades para cada región de 10, 20, 30 y 40 kms.
Se guardaron los tiempos de ejecución de cada prueba para los solvers disponibles de Gecode, Chuffed y COIN-BC, dando un total de 33 pruebas.

\pagebreak

% Table generated by Excel2LaTeX from sheet 'Hoja1'
\begin{table}[h]
    \centering
    \caption{Tiempo de ejecución con Gecode}
      \begin{tabular}{rrr}
      \multicolumn{1}{l}{Región} & \multicolumn{1}{l}{Ciudades} & \multicolumn{1}{l}{Tiempo de ejecución} \\
      10    & 10    & 0.76869392 \\
      10    & 60    & 2.04091954 \\
      20    & 10    & 1.42907691 \\
      20    & 60    & 3.33272505 \\
      20    & 200   & 5.98420763 \\
      30    & 10    & 0.96788192 \\
      30    & 60    & 4.62616611 \\
      30    & 200   & 6.77775455 \\
      40    & 10    & 1.3847568 \\
      40    & 60    & 5.67093301 \\
      40    & 200   & 13.614377 \\
      \end{tabular}%
    \label{tab:addlabel}%
\end{table}%

% Table generated by Excel2LaTeX from sheet 'Hoja1'
\begin{table}[h]
    \centering
    \caption{Tiempo de ejecución con Chuffed}
      \begin{tabular}{rrr}
      \multicolumn{1}{l}{Región} & \multicolumn{1}{l}{Ciudades} & \multicolumn{1}{l}{Tiempo de ejecución} \\
      10    & 10    & 0.3873539 \\
      10    & 60    & 1.57399344 \\
      20    & 10    & 1.02671337 \\
      20    & 60    & 2.59636259 \\
      20    & 200   & 3.78744578 \\
      30    & 10    & 0.55293965 \\
      30    & 60    & 4.37402058 \\
      30    & 200   & 6.65905428 \\
      40    & 10    & 0.95216727 \\
      40    & 60    & 5.58519673 \\
      40    & 200   & 11.2762768 \\
      \end{tabular}%
    \label{tab:addlabel}%
\end{table}%

% Table generated by Excel2LaTeX from sheet 'Hoja1'
\begin{table}[h]
    \centering
    \caption{Tiempo de ejecución con COIN-BC}
      \begin{tabular}{rrr}
      \multicolumn{1}{l}{Región} & \multicolumn{1}{l}{Ciudades} & \multicolumn{1}{l}{Tiempo de ejecución} \\
      10    & 10    & 0.38538647 \\
      10    & 60    & 1.21510696 \\
      20    & 10    & 1.02793622 \\
      20    & 60    & 3.11683702 \\
      20    & 200   & 3.75238562 \\
      30    & 10    & 0.54950166 \\
      30    & 60    & 4.98182368 \\
      30    & 200   & 6.68447185 \\
      40    & 10    & 0.96751904 \\
      40    & 60    & 5.47077727 \\
      40    & 200   & 11.5659254 \\
      \end{tabular}%
    \label{tab:addlabel}%
\end{table}%

\begin{figure}[h!]
    \centering
    \includegraphics[width=\linewidth]{"Comparacion tiempos de ejecucion.png"}
    \caption{Comparación tiempos de ejecución}
\end{figure}

\pagebreak

\section{Conclusiones}
Como conclusion después de analizar los datos obtenidos, se puede afirmar que hay un comportamiento exponencial que depende más del número de ciudades que
del tamaño de la región como tal, este comportamiento se observa en el gráfico de comparación de los tiempos de ejecución donde el número de ciudades es 60
y las regiones de 30 y 40 km es muy similar.
Por otro lado el solver de COIN-BC resulto ser de los más rápidos en tiempo de ejecución para este problema, seguido por Chuffed y por último Gecode,
donde para cada grupo de region/ciudades, se observa que estos dos primeros suelen tener menor tiempo de ejecución que Gecode.

\section{Video explicatorio}
Enlace al video de la interfaz gráfica: \url{https://youtu.be/2YlW46uQn2o}

\end{document}